import ts from "npm:typescript";
import * as fs from "jsr:@std/fs";
import * as path from "jsr:@std/path";
import { transform, SourceGenerator } from "https://raw.githubusercontent.com/maemon4095/SourceGenerator.ts/main/mod.ts";
import { TrieGenerator } from "./tools/GenerateTrie/mod.ts";
import * as esbuild from "npm:esbuild";
import { denoPlugins } from "jsr:@luca/esbuild-deno-loader";

const mode = Deno.args[0];

const generators: SourceGenerator[] = [
    TrieGenerator()
];

const generatedFileHeader = `/*
    this file is generated by source generator.
                DO NOT EDIT.
*/\n`;

const srcDir = "./src";

for await (const entry of fs.expandGlob(`${srcDir}/**/*.gen.ts`)) {
    if (!entry.isFile) continue;
    await Deno.remove(entry.path);
}

switch (mode) {
    case "build": {
        await transformAll((async function* () {
            for await (const e of fs.walk(srcDir)) {
                yield e.path;
            }
        })());
        break;
    }
    case "watch": {
        await transformAll((async function* () {
            for await (const e of fs.walk(srcDir)) {
                yield e.path;
            }

            for await (const e of Deno.watchFs("./src")) {
                yield* e.paths;
            }
        })());
    }
}



async function transformAll(paths: AsyncIterable<string>) {
    const sources: string[] = [];
    for await (const p of paths) {
        sources.push(p);
    }

    const generateSourcePattern = /^.*\.src\.ts$/;
    const workerSourcePattern = /^.*\.worker\.ts$/;
    for (const path of sources) {
        if (path.match(generateSourcePattern)) {
            await generate(path);
        }
    }
    for (const path of sources) {
        if (path.match(workerSourcePattern)) {
            await bundleWorker(path);
        }
    }
}

async function bundleWorker(p: string) {
    const { outputFiles } = await esbuild.build({
        entryPoints: [p],
        bundle: true,
        format: "esm",
        write: false,
        minify: true,
        treeShaking: true,
        plugins: [
            ...denoPlugins({ configPath: path.join(import.meta.dirname!, "./deno.json") })
        ]
    });
    const filepath = p.substring(0, p.length - 3) + ".gen.ts";
    const content = outputFiles[0].text;
    const workerDataUrl = "data:text/javascript;base64," + btoa(content);
    const source = `export default function create(): Worker { return new Worker(${JSON.stringify(workerDataUrl)}); }`;

    await Deno.writeTextFile(filepath, source);
}

async function generate(path: string) {
    const sourceCode = await Deno.readTextFile(path);
    const sourceFile = ts.createSourceFile(path, sourceCode, ts.ScriptTarget.ESNext);
    const generated = await transform(sourceFile, generators);
    if (generated === sourceFile) {
        return;
    }
    const distPath = replaceExt(path, ".gen.ts");
    const content = generatedFileHeader + generated.getFullText();
    console.log("Generated:", distPath);
    await Deno.writeTextFile(distPath, content);
}

function replaceExt(p: string, ext: string) {
    const pattern = /^.*?(?<ext>(\.[^/\\\.]+)*)$/;
    const matches = p.match(pattern);
    const oldExtLen = matches?.groups?.ext?.length ?? 0;
    const withoutExt = p.substring(0, p.length - oldExtLen);
    return `${withoutExt}${ext}`;
}

