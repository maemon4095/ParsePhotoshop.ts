import ts from "npm:typescript";
import * as fs from "https://deno.land/std@0.224.0/fs/mod.ts";
import { transform, SourceGenerator } from "./tools/SourceGenerator/mod.ts";
import { TrieGenerator } from "./tools/GenerateTrie/mod.ts";

const mode = Deno.args[0];

const generators: SourceGenerator[] = [
    TrieGenerator()
];

const generatedFileHeader = `/*
    this file is generated by source generator.
                DO NOT EDIT.
*/\n`;

switch (mode) {
    case "build": {
        for await (const entry of fs.expandGlob("./src/**/*.src.ts")) {
            if (!entry.isFile) continue;
            await generate(entry.path);
        }
        break;
    }
    case "watch": {
        const pattern = /^.*\.src\.ts$/;
        for await (const entry of Deno.watchFs("./src")) {
            for (const p of entry.paths) {
                if (!p.match(pattern)) {
                    continue;
                }
                await generate(p);
            }
        }
        break;
    }
}


async function generate(path: string) {
    const sourceCode = await Deno.readTextFile(path);
    const sourceFile = ts.createSourceFile(path, sourceCode, ts.ScriptTarget.ESNext);
    const generated = await transform(sourceFile, generators);
    if (generated === sourceFile) {
        return;
    }
    const distPath = replaceExt(path, ".gen.ts");
    const content = generatedFileHeader + generated.getFullText();
    console.log("Generated:", distPath);
    await Deno.writeTextFile(distPath, content);
}

function replaceExt(p: string, ext: string) {
    const pattern = /^.*?(?<ext>(\.[^/\\\.]+)*)$/;
    const matches = p.match(pattern);
    const oldExtLen = matches?.groups?.ext?.length ?? 0;
    const withoutExt = p.substring(0, p.length - oldExtLen);
    return `${withoutExt}${ext}`;
}

